# Flash structure

The model of the flash is `25PE10VG 9YJPC VS MYS 1214`, the size is 128kb. The flash data can be read or written using HCI commands: the start address is `0xFF000000`, the end address is `0xFF020000`. Lower addresses won't work; higher addresses will be rounded down to match the flash range.

Defined regions:

| Offset | Size   | Description                              |
|--------|--------|------------------------------------------|
| 0x0000 | 0x3000 | ??? (info?)                              |
| 0x3000 | 0x8000 | ??? (contains ARMv4T little endian code) |
| 0xB000 | 0x1000 | Bluetooth data                           |
| 0xC000 | 0x1000 | Bluetooth data (mirror)                  |
| 0xD000 | 0x8000 | Savegame data                            |

The rest seems to be unused.

### ??? region (0x0000 - 0x3000)

Mostly unknown. First 40 bytes actually hold some data, the rest is `FF`. At `0x15` there is the chip's MAC address, reversed.

### ??? region (0x3000 - 0xB000)

This region does not change across dumps; it also seems to contain executable ARM code. Purpose is unknown.

### Data region (0xB000 - 0xC000)

This region contains informations about the paired keyboard.

| Offset  | Size    | Description                     |
|---------|---------|---------------------------------|
| 0x000   | 0x02    | ??? (LE number)                 |
| 0x002   | 0x06    | Keyboard MAC address            |
| 0x004   | 0xF8    | Keyboard name (null terminated) |
| 0x0FD   | 0x18    | ???                             |
| 0xFFE   | 0x02    | ???                             |

When `000` is nonzero the game does not read from `0xC000`.

### Save region (0xD000 - 0x15000)

This region contains savedata. It's split into sectors, each sector is `0x1000` in size, and if not zero filled, follows this structure:

| Offset | Size     | Description                    |
|--------|----------|--------------------------------|
| 0x000  | 0x004    | "RAXT" magic number            |
| 0x004  | 0x004    | Version                        |
| 0x008  | 0x004    | Size of data                 	 |
| 0x00C  | 0x004    | Save counter                   |
| 0x010  | 0x010    | MD5 hash                       |
| 0x020  | 0x004    | Seed0                          |
| 0x024  | 0x004    | Checksum                       |
| 0x028  | 0xFD8    | Save buffer                    |

Every save slot has 2 dedicated sectors; the game loads the one with the highest save counter (number of times this slot has been modified), unless corrupted, in which case it tries to load from the other sector. If two sectors have the same counter the one that comes later is loaded. Every sector must have the magic number, version equal 1, and size equal `0x7D8` to be loaded.

The MD5 hash is used for corruption detection. It covers the decoded buffer and every field of the sector header in order, up to the hash.

The save buffer is encoded using seeded RNG as a stream cipher. The state of the RNG is seeded using seed0, which is generated by the game, and seed1, which is fixed. The checksum is also encoded using the state after buffer encoding.

The algorithms used are the following:

```c
struct CipherCtx {
  uint32_t state[2];
};

static void cipherInit(CipherCtx *ctx, const uint32_t seed0) {
  ctx->state[0] = seed0;
  ctx->state[1] = ctx->state[0] ^ 0x6ED39B86; // seed1
}

static uint32_t cipherPass(CipherCtx *ctx, const uint32_t w) {
  const uint32_t tmp = ctx->state[0] ^ w;
  ctx->state[0] = w;
  ctx->state[1] = (0x41C64E6D * ctx->state[1]) + 0x3039;
  return tmp ^ ctx->state[1];
}

static uint32_t genChecksum(const uint32_t *buffer, const size_t size) {
  uint32_t chk = 0;

  for (size_t i = 0; i < size; i++) {
    const uint32_t old = chk;
    chk += buffer[i];
    if (old > chk)
      ++chk;
  }

  return ~chk;
}
```